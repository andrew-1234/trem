================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-02T08:05:28.214Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
trem/
  api.py

================================================================
Repository Files
================================================================

================
File: trem/api.py
================
from datetime import datetime
from django.db.models.manager import BaseManager
from django.http import HttpRequest
from ninja import NinjaAPI, Schema
from typing import List, Optional
from rest_framework.pagination import PageNumberPagination
from django.shortcuts import get_object_or_404
from trem_app.models import Note
from django.db.models import Q
# from django.db.models import F

api = NinjaAPI()


class NoteIn(Schema):
    title: Optional[str] = None
    content: Optional[str] = None
    tags: Optional[str] = None
    thread_id: Optional[int] = None


class NoteOut(Schema):
    id: int
    title: str
    content: str
    created_at: datetime
    updated_at: datetime
    tags: str
    slug: str
    # is_reply: bool
    # parent_id: Optional[int]
    replies: List["NoteOut"] = []


NoteOut.model_rebuild()


class NotePagination(PageNumberPagination):
    page_size = 10


# # Create note
# @api.post("/notes")
# def create_note(request: HttpRequest, payload: NoteIn) -> dict[str, int]:
#     note: Note = Note.objects.create(**payload.dict())
#     return {"id": note.id}
# Update the create_note and update_note functions
@api.post("/notes", response=NoteOut)
def create_note(request: HttpRequest, payload: NoteIn) -> Note:
    thread = None
    if payload.thread_id:
        thread = get_object_or_404(Note, id=payload.thread_id)

    note_data = payload.dict(exclude={"thread_id"})
    note = Note.objects.create(**note_data, thread=thread)
    return note


# Get note by ID
@api.get("/notes/{note_id}", response=NoteOut)
def get_note(request: HttpRequest, note_id: int) -> Note:
    note: Note = get_object_or_404(Note, id=note_id)
    return note


# List notes with pagination
@api.get("/notes", response=List[NoteOut])
def list_notes(request: HttpRequest, page: int = 1, page_size: int = 10) -> List[Note]:
    qs: BaseManager[Note] = Note.objects.filter(thread__isnull=True)  # Only root notes
    start = (page - 1) * page_size
    end = start + page_size
    return list(qs[start:end])


# Get replies to a note
@api.get("/notes/{note_id}/replies", response=List[NoteOut])
def get_note_replies(request: HttpRequest, note_id: int) -> List[Note]:
    note: Note = get_object_or_404(Note, id=note_id)
    return list(note.replies.all())


# @api.get("/notes/{note_id}/siblings", response=List[NoteOut])
# def get_sibling_notes(request: HttpRequest, note_id: int) -> List[Note]:
#     note: Note = get_object_or_404(Note, id=note_id)
#     return list(Note.objects.filter(note.thread))


# Get parent note
@api.get("/notes/{note_id}/parent", response=NoteOut)
def get_parent_note(request: HttpRequest, note_id: int) -> Optional[Note]:
    note: Note = get_object_or_404(Note, id=note_id)
    return note.thread


# Get number of database entries in notes
@api.get("/count")
def count_notes(request: HttpRequest):
    count: int = Note.objects.count()
    return {"count": count}


# Update note by ID
@api.put("/notes/{note_id}")
def update_note(request: HttpRequest, note_id: int, payload: NoteIn) -> dict[str, bool]:
    note: Note = get_object_or_404(Note, id=note_id)
    for attr in ["title", "content", "tags"]:
        value = getattr(payload, attr)
        if value is not None:
            setattr(note, attr, value)
    note.save()  # type: ignore
    return {"success": True}


# Delete note by ID
@api.delete("/notes/{note_id}")
def delete_note(request: HttpRequest, note_id: int) -> dict[str, bool]:
    note: Note = get_object_or_404(Note, id=note_id)
    note.delete()
    return {"success": True}


# Search notes by query
@api.get("/search", response=List[NoteOut])
def search_notes2(request: HttpRequest, query: str) -> List[Note]:
    query_words = query.split()
    q_objects = Q()

    for word in query_words:
        q_objects &= (
            Q(title__icontains=word)
            | Q(content__icontains=word)
            | Q(tags__icontains=word)
        )

    results = Note.objects.filter(q_objects)
    return list(results)
