================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-02T08:04:49.181Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
frontend/
  src/
    api/
      ApiNotes.tsx
      index.tsx
    components/
      AddReplyForm.tsx
      Filter.tsx
      HomePagination.tsx
      Modal.tsx
      NavBar.tsx
      NoteCard.tsx
      NoteCardContainer.tsx
      NoteForms.tsx
      UseDebounced.tsx
      UseFetchNote.tsx
    constants/
      NoteRoutes.tsx
      NoteType.tsx
    layouts/
      Main.tsx
    pages/
      AddNotePage.tsx
      EditNotePage.tsx
      Home.tsx
      NotePage.tsx
    App.tsx
    main.tsx

================================================================
Repository Files
================================================================

================
File: frontend/src/api/ApiNotes.tsx
================
import { Note } from '../constants/NoteType';
var BASE_URL = import.meta.env.VITE_APP_API_URL;

// List all notes
export const FetchNotes = async (page: number = 1, page_size: number = 10): Promise<Note[]> => {
  const response = await fetch(`${BASE_URL}/api/notes?page=${page}&page_size=${page_size}`);
  if (!response.ok) {
    throw new Error('Failed to fetch notes');
  }
  return await response.json();
};

// Fetch a single note 
export const FetchNoteById = async (id: number): Promise<Note> => {
  const response = await fetch(`${BASE_URL}/api/notes/${id}`);
  if (!response.ok) {
    throw new Error('Failed to fetch note');
  }
  const data = await response.json();
  return data as Note;
};

// Fetch the total number of notes
export const FetchTotalNotes = async (): Promise<{ count: number }> => {
  console.log(BASE_URL);
  const response = await fetch(`${BASE_URL}/api/count`);
  if (!response.ok) {
    throw new Error('Failed to fetch total notes');
  }
  const data = await response.json();
  return data;
};

// Update a note
export const EditNote = async (note: Note): Promise<Note> => {
  const response = await fetch(`${BASE_URL}/api/notes/${note.id}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(note),
  });
  if (!response.ok) {
    throw new Error('Failed to edit note');
  }
  const data = await response.json();
  return data as Note;
};

// Delete a note
export const DeleteNote = async (id: number): Promise<void> => {
  const response = await fetch(`${BASE_URL}/api/notes/${id}`, {
    method: 'DELETE',
  });
  if (!response.ok) {
    throw new Error('Failed to delete note');
  }
};

// Create a new note
export const CreateNote = async (note: Omit<Note, 'id' | 'created_at' | 'updated_at' | 'slug'>): Promise<number> => {
  const response = await fetch(`${BASE_URL}/api/notes`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(note),
  });
  if (!response.ok) {
    throw new Error('Failed to create note');
  }
  const data = await response.json();
  return data.id;
};

// Get replies for a note
export const FetchNoteReplies = async (noteId: number): Promise<Note[]> => {
  const response = await fetch(`${BASE_URL}/api/notes/${noteId}/replies`);
  if (!response.ok) {
    throw new Error('Failed to fetch replies');
  }
  return await response.json();
};

// Get note Parent tree
export const FetchNoteParent = async (noteId: number): Promise<Note> => {
  const response = await fetch(`${BASE_URL}/api/notes/${noteId}/parent`);
  if (!response.ok) {
    throw new Error('Failed to fetch parent tree');
  }
  return await response.json();
};

// Search notes
export const SearchNotes = async (query: string): Promise<Note[]> => {
  const response = await fetch(`${BASE_URL}/api/search?query=${query}`);
  if (!response.ok) {
    throw new Error('Failed to search notes');
  }
  const data = await response.json();
  return data as Note[];
};

================
File: frontend/src/api/index.tsx
================
export * from './ApiNotes';

================
File: frontend/src/components/AddReplyForm.tsx
================
import React, { useState } from 'react';
import { CreateNote } from '../api/ApiNotes';

interface ReplyFormProps {
  parentNoteId: number;
  onReplyAdded: () => void;
}

const ReplyForm: React.FC<ReplyFormProps> = ({ parentNoteId, onReplyAdded }) => {
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [tags, setTags] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await CreateNote({
        title,
        content,
        tags,
        thread_id: parentNoteId,
      });
      setTitle('');
      setContent('');
      setTags('');
      onReplyAdded();
    } catch (error) {
      console.error('Failed to add reply:', error);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="card-body border-top">
      <div className="mb-3">
        <input
          type="text"
          className="form-control"
          placeholder="Reply title"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          required
        />
      </div>
      <div className="mb-3">
        <textarea
          className="form-control"
          placeholder="Reply content"
          value={content}
          onChange={(e) => setContent(e.target.value)}
          required
        />
      </div>
      <div className="mb-3">
        <input
          type="text"
          className="form-control"
          placeholder="Tags (comma separated)"
          value={tags}
          onChange={(e) => setTags(e.target.value)}
        />
      </div>
      <button type="submit" className="btn btn-primary">Add Reply</button>
    </form>
  );
};

export default ReplyForm;

================
File: frontend/src/components/Filter.tsx
================
import { ChangeEvent, useEffect } from "react";
import { Note } from "../constants/NoteType";
import { SearchNotes } from "../api";
import { UseDebounced } from "../components/UseDebounced";

interface FilterProps {
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  setSearchResults: (results: Note[]) => void;
}

const Filter = ({ searchQuery, setSearchQuery, setSearchResults }: FilterProps) => {
  const debouncedSearchQuery = UseDebounced(searchQuery, 500); // 500ms debounce

  useEffect(() => {
    const handleSearch = async (query: string) => {
      if (query.length === 0) {
        setSearchResults([]);
        return;
      }
      try {
        const results = await SearchNotes(query);
        setSearchResults(results);
      } catch (err) {
        console.error('Failed to search notes', err);
        setSearchResults([]);
      }
    };

    if (debouncedSearchQuery) {
      handleSearch(debouncedSearchQuery);
    } else {
      setSearchResults([]);
    }
  }, [debouncedSearchQuery, setSearchResults]);

  const handleInputChange = (e: ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  };

  return (
    < div
      className="input-group"
    >

      <input
        className="form-control"
        type="search"
        placeholder="Filter"
        aria-label="Search"
        value={searchQuery}
        onChange={handleInputChange}
      />


    </div >
  );
};

export default Filter;

================
File: frontend/src/components/HomePagination.tsx
================
interface PaginationProps {
  pageCount: number;
  onPageChange: (page: number) => void;
  currentPage: number;
}

export const HomePagination = (props: PaginationProps) => {
  const pageNumbers = [];
  for (let i = 1; i <= props.pageCount; i++) {
    pageNumbers.push(i);
  }

  return (
    <nav className="pagination-container justify-content-end ">
      <button
        className="btn btn-pagination btn-first-last"
        onClick={() => props.onPageChange(1)}
        disabled={props.currentPage === 1}
      >
        First
      </button>
      {pageNumbers.map((number) => (
        <button
          key={number}
          onClick={() => props.onPageChange(number)}
          className={`btn btn-pagination ${props.currentPage === number ? "active" : ""
            }`}
        >
          {number}
        </button>
      ))}
      <button
        onClick={() => props.onPageChange(props.pageCount)}
        disabled={props.currentPage === props.pageCount}
        className="btn btn-pagination btn-first-last"
      >
        Last
      </button>
    </nav>
  );
};

================
File: frontend/src/components/Modal.tsx
================
import React from 'react';

interface ModalProps {
  title: string;
  children: React.ReactNode;
  onClose: () => void;
}

const Modal = ({ children, onClose }: ModalProps) => {
  return (
    <div className="modal show" style={{ display: 'block', backgroundColor: '' }}>
      <button type="button" className="btn-close" aria-label="Close" onClick={onClose}></button>
      <div className="modal-body">
        {children}
      </div>
    </div>
  );
};

export default Modal;

================
File: frontend/src/components/NavBar.tsx
================
import { Link } from "react-router-dom";

const NavBar = () => {


  return (
    <nav className="navbar navbar-trem" >
      <div className="container d-flex justify-content-left">
        <Link className="navbar-brand" to="/">
          <h3 style={{ fontWeight: "bold" }}>Trem notes</h3>
        </Link>
      </div>
    </nav >
  )
}

export default NavBar;

================
File: frontend/src/components/NoteCard.tsx
================
import React, { useState } from 'react';
import { Link } from "react-router-dom";
import { Note } from '../constants/NoteType';
import { NoteRoutes } from '../constants/NoteRoutes';
import ReplyForm from './AddReplyForm';
import { useParams } from 'react-router-dom';
import styled from 'styled-components';

type NoteCardProps = {
  note: Note;
  color?: string;
  depth?: number;
  onReplyAdded: () => void;
};

const StyledNoteCard = styled.div`
  background-color: ${props => props.color};
`;

// Add a styled component for the NoteCard that changes background color based
// on the color prop
const NoteCard: React.FC<NoteCardProps> = ({ note, color, depth = 0, onReplyAdded }) => {
  const [showReplies, setShowReplies] = useState(false);
  const [showReplyForm, setShowReplyForm] = useState(false);
  const tagsArray = note.tags.split(/[, ]+/).map(tag => tag.trim()).filter(tag => tag.length > 0);
  const { id } = useParams();
  return (
    <div className={`single-note-item ${depth > 0 ? 'reply' : ''}`} style={{ marginLeft: `${depth * 20}px` }}>
      <StyledNoteCard color={color} className='card card-body mb-1'>
        {/* <div className={`card card-body ${color ? 'currentCard' : ''} mb-3`}> */}
        <Link to={NoteRoutes.NOTE_INFO(note.id.toString())} style={{ textDecoration: 'none' }}>
          <h5 className="note-title text-truncate w-75" data-note-title={note.title}>{note.title}</h5>
        </Link>

        <h6 className="mb-2 text-black text-opacity-50">Created: {new Date(note.created_at).toLocaleString()}</h6>

        <div className="tags mb-2">
          {tagsArray.map((tag, index) => (
            <span key={index} className="badge bg-primary me-1">{tag}</span>
          ))}
        </div>

        <div className="card-text text-truncate" data-card-text={note.content}>
          {note.content}
        </div>

        {depth === 0 && (
          <button onClick={() => setShowReplyForm(!showReplyForm)} className="btn btn-outline-primary mt-2">
            {showReplyForm ? 'Cancel Reply' : 'Reply'}
          </button>
        )}

        {showReplyForm && (
          <ReplyForm
            parentNoteId={note.id}
            onReplyAdded={() => {
              setShowReplyForm(false);
              onReplyAdded();
            }}
          />
        )}

        {note.replies && note.replies.length > 0 && (
          <button onClick={() => setShowReplies(!showReplies)} className="btn btn-link">
            {showReplies ? 'Hide' : 'Show'} Replies ({note.replies.length})
          </button>
        )}

        {showReplies && note.replies && note.replies.map(reply => (
          <NoteCard key={reply.id} note={reply} color={Number(id) === reply.id ? '#B4FF7B' : ''} depth={depth + 1} onReplyAdded={onReplyAdded} />
        ))}
      </StyledNoteCard>
    </div >
  );
};

export default NoteCard;

================
File: frontend/src/components/NoteCardContainer.tsx
================
import NoteCard from "./NoteCard";
import { Note } from "../constants/NoteType";

interface NoteCardContainerProps {
  totalNotes: number;
  notes: Note[];
  error: string | null;
  onReplyAdded: () => void;
}

const NoteCardContainer = ({
  totalNotes,
  notes,
  error,
  onReplyAdded,
}: NoteCardContainerProps) => {

  const dummyNote: Note = {
    id: 0,
    title: "Your First Note - Welcome!",
    content: "Click the title to get started.",
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    tags: "inbox get-started",
    slug: "",
    thread_id: null,
  };

  const renderContent = () => {
    if (error) {
      return <div>Error: {error}</div>;
    }
    if (totalNotes === 0) {
      return (
        <div className="list">
          <NoteCard note={dummyNote} onReplyAdded={onReplyAdded} />
        </div>
      );
    }
    return notes.map((note) => (
      <div key={note.id} className="list">
        <NoteCard note={note} onReplyAdded={onReplyAdded} />
      </div>
    ));
  };

  return (
    <div className="container">
      <div className="row">
        {renderContent()}
      </div>
    </div>
  );
};

export default NoteCardContainer;

================
File: frontend/src/components/NoteForms.tsx
================
import React, { useState } from 'react';
import { Note } from '../constants/NoteType';

interface NoteFormProps {
  onSubmit: (note: Note) => void;
  passedNote?: Note;
}

function NoteForms(props: NoteFormProps) {
  // If passed note is provided, use it as initial state
  const initialNote = props.passedNote ? props.passedNote : {
    id: 0,
    title: '',
    content: '',
    tags: '',
    created_at: '',
    updated_at: '',
    slug: '',
    thread_id: null,
  };

  const [note, setNote] = useState<Note>(initialNote);

  // Set state when form input changes
  function handleChange(event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) {
    var { name, value } = event.target;
    setNote({
      ...note,
      [name]: value
    })
  }

  // Handle form submission event using the passed onSubmit prop
  function handleSubmit(event: React.FormEvent) {
    event.preventDefault();
    if (note.tags && note.tags.length > 0) {
      // If note has tags, check if the values are comma separated
      // If not, convert to comma separated
      var value = note.tags
      note.tags = value.split(/[, ]+/).map(tag => tag.trim()).filter(tag => tag.length > 0).join(', ')
    }

    props.onSubmit(note);
  }

  return (
    <div className="container col-6">
      <form onSubmit={handleSubmit}>

        {/* Container Header */}
        <h1 style={{ textAlign: 'center' }} >{note.id ? 'Edit Note' : 'Create a Note'}</h1>

        {/* Title form*/}
        <div className="mb-3">
          <label className="form-label">Title</label>
          <input
            className="form-control"
            placeholder="Enter note's title"
            value={note.title}
            name="title"
            onChange={handleChange}
          ></input>
        </div>

        {/* Content form */}
        <div className="mb-3">
          <label className="form-label">Content</label>
          <textarea
            className='form-control'
            placeholder='Enter note content'
            value={note.content}
            name="content"
            onChange={handleChange}
            rows={10}
          ></textarea>
        </div>

        {/* Tags form */}
        <div className="mb-3">
          <label className="form-label">Tags</label>
          <small id="optional" className="form-text text-muted float-end">Optional</small>
          <input
            className="form-control"
            placeholder="Enter tags (comma separated)"
            value={note.tags}
            name="tags"
            onChange={handleChange}
          ></input>
        </div>


        {/* Submit button */}
        <button
          className="btn btn-primary d-flex justify-content-center mt-3"
          style={{ width: "100%" }}
        >
          {note.id ? 'Save Note' : 'Add Note'}
        </button>
      </form>
    </div>
  )
}

export default NoteForms

================
File: frontend/src/components/UseDebounced.tsx
================
import { useState, useEffect } from 'react';

export const UseDebounced = (inputValue: any, delay: number) => {
  const [debouncedValue, setDebouncedValue] = useState(inputValue);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(inputValue);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [inputValue, delay]);

  return debouncedValue;
};

================
File: frontend/src/components/UseFetchNote.tsx
================
import { useState, useEffect } from 'react';
import { FetchNoteById } from '../api/';
import { Note } from '../constants/NoteType';

export const UseFetchNote = (id: number) => {
  // export function useFetchNote(id: number) {
  const [note, setNote] = useState<Note>({} as Note)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const loadNote = async () => {
      try {
        const noteData = await FetchNoteById(id)
        setNote(noteData)
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Unknown error'
        setError(errorMessage)
      } finally {
        setLoading(false)
      }
    };

    loadNote()
  }, [id])

  return { note, setNote, loading, error }
}

================
File: frontend/src/constants/NoteRoutes.tsx
================
export const NoteRoutes = {
  NOTE_INFO: function (id: string) { return "/note/" + id; },
  ADD_NOTE: "/add/note",
  EDIT_NOTE: function (id: string) { return "/edit/note/" + id; },
}

================
File: frontend/src/constants/NoteType.tsx
================
export interface Note {
  id: number;
  title: string;
  content: string;
  created_at: string;
  updated_at: string;
  tags: string;
  slug: string;
  thread_id: number | null;
  replies?: Note[];
}

================
File: frontend/src/layouts/Main.tsx
================
import NavBar from "../components/NavBar"
import { Outlet } from "react-router-dom"

const Main = () => {
  return (
    <>
      <NavBar></NavBar>
      <Outlet />
    </>
  )
}

export default Main

================
File: frontend/src/pages/AddNotePage.tsx
================
// import { useEffect } from 'react'
// import { CreateNote } from '../api'
// import NoteForms from '../components/NoteForms'
// import { Note } from '../constants/NoteType'
// import { useNavigate } from 'react-router-dom'

// function AddNotePage() {

//   const navigate = useNavigate()
//   useEffect(() => {
//     document.title = 'Add Note'
//   })
//   const submitNote = async (note: Note) => {
//     try {
//       const createdNoteID = await CreateNote(note);
//       console.log('Note created:', createdNoteID);
//       navigate(`/note/${createdNoteID}`);
//     } catch (error) {
//       console.error('Error creating note:', error);
//     }
//   }
//   return (
//     <div>
//       <NoteForms onSubmit={submitNote} />
//     </div>
//   )
// }

// export default AddNotePage
import { useEffect } from 'react';
import { CreateNote } from '../api';
import NoteForms from '../components/NoteForms';
import { Note } from '../constants/NoteType';
import { useNavigate } from 'react-router-dom';
import Modal from '../components/Modal';

interface AddNotePageProps {
  onClose: () => void;
}

function AddNotePage({ onClose }: AddNotePageProps) {

  const navigate = useNavigate();

  useEffect(() => {
    document.title = 'Add Note';
  }, []);

  const submitNote = async (note: Note) => {
    try {
      const createdNoteID = await CreateNote(note);
      console.log('Note created:', createdNoteID);
      navigate(`/note/${createdNoteID}`);
    } catch (error) {
      console.error('Error creating note:', error);
    }
  };

  return (
    <Modal title="Add Note" onClose={onClose}>
      <div className="container">
        <NoteForms onSubmit={submitNote} />
      </div>

    </Modal>
  );
}

export default AddNotePage;

================
File: frontend/src/pages/EditNotePage.tsx
================
import { useNavigate, useParams } from 'react-router-dom'
import { useEffect } from 'react'
import { Note } from '../constants/NoteType'
import { EditNote } from '../api';
import { UseFetchNote } from '../components/UseFetchNote';
import NoteForms from '../components/NoteForms'

function EditNotePage() {
  const navigate = useNavigate()

  // Set the document title
  useEffect(() => {
    document.title = 'Edit Note'
  })

  // Fetch note data by ID
  const { id } = useParams<{ id: string }>();
  const { note, loading, error } = UseFetchNote(Number(id));


  // Return if loading, error, or note not found
  if (loading) {
    return <div>Loading...</div>;
  }
  if (error) {
    return <div>Error: {error}</div>;
  }
  if (!note) {
    return <div>Note not found</div>;
  }

  // Define the submitNote function
  const submitNote = async (note: Note) => {
    await EditNote(note);
    console.log('Note edited:', id);
    navigate(`/note/${id}`)
  }

  // Return the NoteForm, passing the note and the submitNote function
  return (
    <div>
      <NoteForms onSubmit={submitNote} passedNote={note} />
    </div>
  )
}

export default EditNotePage

================
File: frontend/src/pages/Home.tsx
================
import { Fragment, useCallback, useEffect, useState } from 'react';
import Filter from '../components/Filter';
import NoteCardContainer from '../components/NoteCardContainer';
import { FetchNotes, FetchTotalNotes } from '../api';
import { Note } from '../constants/NoteType';
import { HomePagination } from '../components/HomePagination';
// import { Link } from 'react-router-dom';
import { FaSquarePlus } from 'react-icons/fa6';
// import { NoteRoutes } from '../constants/NoteRoutes';
import AddNotePage from './AddNotePage';

const Home = () => {
  const [total, setTotalNotes] = useState<number>(0);
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<Note[]>([]);
  const [page, setPage] = useState(1);
  const [notes, setNotes] = useState<Note[]>([]);
  const [error, setError] = useState<string | null>(null);
  const page_size = 10; // Set the number of notes per page


  useEffect(() => {
    const getTotalNotes = async () => {
      setError(null);
      try {
        const data = await FetchTotalNotes();
        setTotalNotes(data.count);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Unknown error';
        setError(errorMessage);
      }
    };

    getTotalNotes();
  }, []);

  useEffect(() => {
    const loadNotes = async () => {
      setError(null);
      try {
        if (!searchQuery) {
          const notesData = await FetchNotes(page, page_size);
          setNotes(notesData);
        } else if (searchResults !== notes) {
          // Update notes when search results change, even if empty
          setNotes(searchResults);
        }
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Unknown error';
        setError(errorMessage);
      }
    };

    loadNotes();
  }, [page, searchQuery, searchResults]);

  const page_count = searchQuery
    ? Math.ceil(searchResults.length / page_size)
    : Math.ceil(total / page_size);

  useEffect(() => {
    document.title = 'Home';
  }, []);
  const [showModal, setShowModal] = useState(false);

  const openModal = () => setShowModal(true);
  const closeModal = () => setShowModal(false);

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {  // Check if the Esc key was pressed
        closeModal();
      }
    };

    document.addEventListener('keydown', handleKeyDown);

    // Clean up the event listener when the component is unmounted or when showModal changes
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [showModal]);

  const refreshNotes = useCallback(async () => {
    setError(null);
    try {
      const notesData = await FetchNotes(page, page_size);
      setNotes(notesData);
      const data = await FetchTotalNotes();
      setTotalNotes(data.count);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error';
      setError(errorMessage);
    }
  }, [page, page_size]);

  return (
    <Fragment>
      <div className="container action-bar">
        <div className="action-inner">
          <Filter
            searchQuery={searchQuery}
            setSearchQuery={setSearchQuery}
            setSearchResults={setSearchResults}
          />
          <div>
            <button
              className="btn btn-outline-primary add-note"
              type="button"
              onClick={openModal}
            >
              <FaSquarePlus /> Add Notes
            </button>

            {(showModal &&
              <AddNotePage onClose={closeModal} />
            )}
          </div>
        </div>
        <HomePagination
          pageCount={page_count}
          onPageChange={setPage}
          currentPage={page}
        />
      </div>
      <NoteCardContainer
        totalNotes={total}
        notes={notes}
        error={error}
        onReplyAdded={refreshNotes}
      />
    </Fragment>
  );
};

export default Home;

================
File: frontend/src/pages/NotePage.tsx
================
import React, { useEffect, useState, useCallback } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import { BiSave, BiSolidTrashAlt } from 'react-icons/bi';
import { Modal, Button, ButtonGroup, Toast, ToastContainer } from 'react-bootstrap';
import MDEditor from '@uiw/react-md-editor';
import styled from 'styled-components';

import { DeleteNote, EditNote, FetchNoteParent } from '../api';
import { Note } from '../constants/NoteType';
import { UseFetchNote } from '../components/UseFetchNote';
import NoteCard from '../components/NoteCard';
import rehypeSanitize from 'rehype-sanitize';

// Styled components
const Container = styled.div`
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
`;

const Title = styled.h1`
  margin: 0;
`;

const Metadata = styled.div`
  border: 1px solid #5938df;
  padding: 10px;
  margin-bottom: 20px;
  border-radius: 5px;
`;

const ButtonContainer = styled.div`
  display: flex;
  justify-content: flex-end;
  margin-bottom: 20px;
`;

const StyledMDEditor = styled(MDEditor)`
  --color-canvas-default: white;
  --color-fg-default: black;
  --color-border-default: #5938df  
  margin-bottom: 20px;
  margin-top: 10px;
  border-radius: 10px;
  border: 1px solid #5938df;
  box-shadow: 0 0 0;
  
  .w-md-editor-preview {
  }
  
  .w-md-editor-toolbar {
    border-top: 0px;
    border-left: 0px;
    border-right: 0px;
    border-bottom: 1px solid #5938df;
    background-color: transparent;
}
`;

const StyledToastContainer = styled(ToastContainer)`
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 9999;
`;

const NotePage: React.FC = () => {
  const navigate = useNavigate();
  const { id } = useParams<{ id: string }>();
  const { note, setNote, loading, error } = UseFetchNote(Number(id));
  const [expandedReplies, setExpandedReplies] = useState(false);

  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [editorState, setEditorState] = useState({
    content: '',
    preview: 'edit' as 'edit' | 'live' | 'preview',
  });
  const [toast, setToast] = useState({ show: false, message: '', variant: 'success' });

  // Check if note has replies and display the replies in the sidcebar if yes 

  const [parentTree, setParentTree] = useState<Note | null>(null);

  useEffect(() => {
    if (note) {
      setEditorState(prev => ({ ...prev, content: note.content }));
      // document.title = `Note: ${note.title.slice(0, 20)}`;
      setParentTree(null);
      const loadParentTree = async () => {
        const noteParentTree = await FetchNoteParent(Number(id));
        setParentTree(noteParentTree);
      }

      loadParentTree();
      if (parentTree == null) {
        <div>No parent tree</div>
      } else {
        <div className="list">
          <NoteCard note={parentTree} onReplyAdded={onReplyAdded} />
        </div>
      }

      if (note.title) {
        const truncatedTitle = note.title.length > 20 ? note.title.slice(0, 20) : note.title;
        document.title = `Note: ${truncatedTitle}`;
      }
    }
  }, [note]);



  const showToast = (message: string, variant: 'success' | 'danger') => {
    setToast({ show: true, message, variant });
  };

  const handleSave = useCallback(async () => {
    if (!note) return;
    const updatedNote: Note = { ...note, content: editorState.content };
    try {
      await EditNote(updatedNote);
      setNote(updatedNote);
      showToast('Note saved successfully!', 'success');
    } catch (err) {
      console.error('Failed to save note', err);
      showToast('Failed to save note. Please try again.', 'danger');
    }
  }, [note, editorState.content, setNote]);

  const handleDelete = useCallback(async () => {
    if (!note) return;
    try {
      await DeleteNote(note.id);
      showToast('Note deleted successfully!', 'success');
      // Delay navigation to allow toast to be visible
      setTimeout(() => {
        navigate('/');
      }, 1500); // Adjust this delay as needed
    } catch (err) {
      console.error('Failed to delete note', err);
      showToast('Failed to delete note. Please try again.', 'danger');
    }
  }, [note, navigate]);

  if (loading) return <Container>Loading...</Container>;
  if (error) return <Container>Error: {error}</Container>;
  if (!note) return <Container>Note not found</Container>;
  const tagsArray = note.tags.split(/[, ]+/).map(tag => tag.trim()).filter(tag => tag.length > 0);

  const onReplyAdded = () => { }
  const renderReplies = () => {
    {
      note.replies ? note.replies.map(reply => (
        <NoteCard key={reply.id} note={reply} onReplyAdded={onReplyAdded} />
      )) : <div>No replies yet</div>
    }
    if (note.replies && note.replies.length > 0) {
      return note.replies.map(reply => (
        <NoteCard key={reply.id} note={reply} onReplyAdded={onReplyAdded} />
      ));
    } else {
      return <div>No replies yet</div>;
    }
  }


  // const renderReplies = () => {
  //   if (note.replies) {
  //     const displayedReplies = showAllReplies ? note.replies : [note.replies[0]];
  //     return (
  //       <>
  //         {displayedReplies.map(reply => (
  //           <NoteCard key={reply.id} note={reply} onReplyAdded={onReplyAdded} />
  //         ))}
  //         {note.replies.length > 1 && (
  //           <Button
  //             variant="link"
  //             onClick={() => setShowAllReplies(!showAllReplies)}
  //           >
  //             {showAllReplies ? 'Hide' : 'Show'} {note.replies.length - 1} more {note.replies.length - 1 === 1 ? 'reply' : 'replies'}
  //           </Button>
  //         )}
  //       </>
  //     );
  //   } else {
  //     return <div>No replies yet</div>;
  //   }
  // }
  const renderParentTree = () => {

    if (!!!parentTree || parentTree == null) {
      return <div>No parent tree</div>;
    } else {
      return (
        <div className="list">
          <NoteCard note={parentTree} onReplyAdded={onReplyAdded} />
        </div>
      );
    }
  };

  return (
    <Container>
      <Header>
        <Title>{note.title}</Title>
        <Button variant="primary" size="sm" onClick={() => navigate(-1)}>
          Back
        </Button>
      </Header>

      <Metadata>
        <div>Created: {new Date(note.created_at).toLocaleString()}</div>
        <div>Updated: {new Date(note.updated_at).toLocaleString()}</div>
        <div>
          Tags:
          {tagsArray.map((tag, index) => (
            <span key={index} className="badge bg-primary me-1">
              {tag}
            </span>
          ))}
        </div>
      </Metadata>

      <ButtonContainer>
        <Button variant="success" size="sm" className="me-2" onClick={handleSave}>
          <BiSave /> Save
        </Button>
        <Button variant="danger" size="sm" className="me-2" onClick={() => setShowDeleteConfirm(true)}>
          <BiSolidTrashAlt /> Delete
        </Button>
        <ButtonGroup size="sm">
          {(['edit', 'live', 'preview'] as const).map((mode) => (
            <Button
              key={mode}
              variant={editorState.preview === mode ? 'primary' : 'outline-secondary'}
              onClick={() => setEditorState(prev => ({ ...prev, preview: mode }))}
            >
              {mode.charAt(0).toUpperCase() + mode.slice(1)}
            </Button>
          ))}
        </ButtonGroup>
      </ButtonContainer>

      <StyledMDEditor data-color-mode="light"
        value={editorState.content}
        onChange={(value) => setEditorState(prev => ({ ...prev, content: value || '' }))}
        preview={editorState.preview}
        previewOptions={{
          rehypePlugins: [[rehypeSanitize]],
        }}
        height={400}
      />

      {/* See 1) note replies 2) Note parent tree */}
      <div className="container">
        <div className="row">
          <h4>Replies</h4>
          {/* {renderReplies()} */}
          {note.replies && note.replies.length > 0 && (
            <>
              {note.replies.length > 1 && (
                <div className="d-inline">
                  {/* <div className="d-flex justify-content-end mt-2"> */}

                  <Button
                    variant="outline-info" size="sm"
                    onClick={() => setExpandedReplies(!expandedReplies)}
                  >
                    {expandedReplies ? 'Show less' : `Show ${note.replies.length - 1} more replies`}
                  </Button>
                </div>
              )}
              {expandedReplies
                ? renderReplies()
                : (() => {
                  const result = renderReplies();
                  return Array.isArray(result) ? result.slice(0, 1) : result;
                })()
              }
            </>
          )}
          {(!note.replies || note.replies.length === 0) && renderReplies()}
          <h4>Parent Tree</h4>
          {renderParentTree()}
        </div>
      </div>

      <Modal show={showDeleteConfirm} onHide={() => setShowDeleteConfirm(false)}>
        <Modal.Header closeButton>
          <Modal.Title>Confirm Delete</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          Are you sure you want to delete this note? This action cannot be undone.
        </Modal.Body>
        <Modal.Footer>
          <Button variant="secondary" onClick={() => setShowDeleteConfirm(false)}>
            Cancel
          </Button>
          <Button variant="danger" onClick={handleDelete}>
            Delete
          </Button>
        </Modal.Footer>
      </Modal>
      <StyledToastContainer>
        <Toast
          show={toast.show}
          onClose={() => setToast(prev => ({ ...prev, show: false }))}
          delay={3000}
          autohide
          bg={toast.variant}
        >
          <Toast.Header>
            <strong className="me-auto">Notification</strong>
          </Toast.Header>
          <Toast.Body>{toast.message}</Toast.Body>
        </Toast>
      </StyledToastContainer>
    </Container>
  );
};

export default NotePage;

================
File: frontend/src/App.tsx
================
import { createBrowserRouter, createRoutesFromElements, Route, RouterProvider } from 'react-router-dom'

import './custom.scss'
import { NoteRoutes } from './constants/NoteRoutes'
import Home from './pages/Home'
import Main from './layouts/Main'
import NotePage from './pages/NotePage'
import EditNotePage from './pages/EditNotePage'
export default function App() {

  const router = createBrowserRouter(
    createRoutesFromElements(
      <Route path="/" element={<Main />} >
        <Route index element={<Home />} />
        <Route path={NoteRoutes.NOTE_INFO(":id")} element={<NotePage />} />
        {/* <Route path={NoteRoutes.ADD_NOTE} element={<AddNotePage />} /> */}
        <Route path={NoteRoutes.EDIT_NOTE(":id")} element={<EditNotePage />} />
      </Route >
    )
  )

  return <RouterProvider router={router} />
}

================
File: frontend/src/main.tsx
================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
